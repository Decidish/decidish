## 4. System Architecture

![System Architecture](system_architecture.png)

<!-- TODO: Personalisation Service-->
### Client
Mobile and Web Frontend application to connect to the API Gateway.

### API Gateway / Load Balancer
Manages the different calls to the different services.

### Core Services
1. **Order Service:** Adds a recipe to the shopping list.
2. **User Service:** Stores user's information profile, dietary preferences (e.g. whether they are vegan, can't eat pork, etc).
3. **Shopping List Service:** Generate a shopping list based on the user's chosen recipes and their ingredients availability. 
4. **Inventory Service:** Check whether the ingredients in the shopping list are available in supermarkets nearby.
5. **Recipe Service:** Get the ingredients needed for a certain recipe.

### Personalisation Services
1. **Recommendation Service:** Get the K top recipes that this user is most likely to enjoy.
2. **Interaction Service:** Stores whether the user likes of dislikes the recommendations.
3. **Personalisation Service:** Retrieves the user vector of preferences. 

### Data and Machine Learning Pipeline
1. **Streaming Jobs (Kafka):** In order to avoid having to retrain the Machine Learning Module everytime the user likes or dislikes some recipe, we store this information and retrain our module once enough time has passed and/or enough data has been retrieved. This will be done with Kafka.
2. **Machine Learning Pipeline:** Updates user vector of preference with a Machine Learning algorithm based on the data provide by the job streamer.

### Data Layer
1. **Vector Data Base:** Stores user's vectors of preference generated by the Machine Learning Pipeline based on the user input and the recipe's vectors base on the recipes parameters.
2. **Recipe Data Server:** Stores all the known recipes with their associated data (e.g. ingredients, etc).

### External APIs
**Supermarket APIs:** Gets the current availability of the ingredients needed for the selected recipes in supermarkets nearby to the user.

## 5. Technology Stack

### 1. Frontend
* **Framework:** React Native (for iOS, Android, and Web/Desktop)
* **Language:** TypeScript
* **API Comms:** REST API (Initial MVP).
    * *Note: Consider GraphQL if request amplification becomes an issue, but it is likely too complex for the MVP.*

### 2. Reverse Proxy / API Gateway
* **Tool:** Nginx
* **Responsibilities:** Load Balancing, API Gateway.

### 3. Personalisation Server
* **Language :** C#, dotnet

### 4. Recipe Server
* **Language:** Java 

### 5. Database Layer
* **Primary DB:** PostgreSQL
* **Vector DB:** Pinecone

### 6. Training / ML Pipeline
* **Purpose:**
    * Update the vector database.
    * Retrieve jobs from a Kafka streaming pipeline.
* **Stack:** Python (PyTorch, Scikit-learn, etc.)
* **Messaging:** Kafka

## 6. Project Scope

### 1. Functional Requirements (FR)
* **FR1:** The system shall suggest suitable recipes based on the user's available ingredients.
* **FR2:** The system shall retrieve available products from local markets.
* **FR3:** The system shall generate personalized recipe recommendations.
* **FR4:** The system shall find nearest markets (based on user location).
* **FR5:** The system shall generate a shopping list (with specific ingredients from supermarkets) based on the user's chosen recipes.
* **FR6:** The system shall store user features, preferences, and profile information.
* **FR7:** The system shall track and store the user's recipe history (e.g., liked/disliked meals).

### 2. Non-Functional Requirements (NFR)

* **NFR1: Usability**
    * A user must be able to generate a shopping list within 10 clicks from the main dashboard.
* **NFR2: Robustness**
    <!-- * *[To be defined - e.g., error handling, fault tolerance]* -->
    * System must continue operating despite failures of individual components.
    * Microservices must degrade gracefully (e.g. show "Availability unknown" if supermarket APIs fail).
    * All user and recipe data must remain consistent under concurrent access.
* **NFR3: Performance**
    * **Scalability:** The system must support horizontal scaling. 
    * **Storage:** The system must handle an average of 50 MB of data per user.
    * **Transaction Speed:** critical transactions must be completed in under 150 ms.
    * **Response Time:** P95 (95th percentile) response time should be under 300 ms per user request.
* **NFR4: Availability**
    * The system shall be available 95% of the time (uptime).
* **NFR5: Portability**
    * The application must be deployable on Android, iOS, and modern Web browsers.
